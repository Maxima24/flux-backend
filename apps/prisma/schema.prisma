// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @default(uuid()) @id
  walletAddress String       @unique
  deposits      Deposit[]
  allocations   Allocation[]
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model Protocol {
  id               String       @default(uuid()) @id
  name             String
  protocol_type    String //e.g. Lending , statking ,Liquidity
  contract_address String
  chain            String
  isActive         String
  currentApy       Float
  riskScore        Float
  allocations      Allocation[]
  apyHistory       ApyHistory[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

model Deposit {
  id           String       @default(uuid()) @id
  userId       String
  user         User         @relation(references: [id], fields: [userId])
  assetAddress String
  assetSymbol  String
  amount       Float
  txHash       String
  status       DepositStatus @default(PENDING)
  allocations  Allocation[]
  createdAt    DateTime     @default(now())
  updateAt     DateTime     @updatedAt
}

model Allocation {
  id              String           @default(uuid()) @id
  depositId       String
  deposit         Deposit          @relation(references: [id], fields: [depositId])
  userId          String
  user            User             @relation(references: [id], fields: [userId])
  protocolId      String
  protocol        Protocol         @relation(references: [id], fields: [protocolId])
  allocatedAmount Float
  currentValue    Float
  allocatedAt     DateTime         @default(now())
  status          AllocationStatus @default(ACTIVE)
  aiConfidence    Float
  expectedApy     Float
  actualApt       Float
  transactions    Transaction[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
}

model Transaction {
  id     String          @default(uuid()) @id
  allocationId String
  allocation  Allocation  @relation(references: [id],fields: [allocationId])
  type   TransactionType
  txhash String          @unique
  status TxStatus
  amount Float
  gasUsed Float?


  createdAt DateTime @default(now())
}

model ApyHistory {
  id          String   @id @default(uuid()) 
  protocolId  String
  protocol    Protocol @relation(fields: [protocolId], references: [id])
  apy         Float
  timestamp   DateTime @default(now())
}

model AiDecision {
  id              String   @id @default(uuid()) 
  depositId       String
  inputData       Json     // Store the data fed to AI
  outputData      Json     // Store AI's recommendation
  confidence      Float
  reasoning       String?  // AI's explanation
  executedAt      DateTime @default(now())
}

enum DepositStatus {
  PENDING
  PROCESSING
  ALLOCATED
  FAILED
}

enum AllocationStatus {
  ACTIVE
  WITHDRAWN
  REBALANCING
  FAILED
}

enum TransactionType {
  DEPOSIT
  ALLOCATE
  WITHDRAW
  REBALANCE
}

enum TxStatus {
  PENDING
  CONFIRMED
  FAILED
}
// ============================================
// MONITORING
// ============================================

model SystemHealth {
  id String @id @default(uuid())

  service     String
  status      String
  lastCheckAt DateTime @default(now())

  metrics    Json?
  errorCount Int     @default(0)
  lastError  String? @db.Text

  @@index([service, lastCheckAt(sort: Desc)])
  @@map("system_health")
}
